Simple Chat NPCs
=================

This section of the tutorial aims to guide you through the process of creating semantic non-player characters (NPCs) that can hold interactive conversations in your Godot engine game. It assumes that you have completed the project setup and have configured the OPENAI_API_KEY user secret.

Creating a Basic NPC
--------------------

Step 1: Creating the NPC Sprite
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

1. In the Scene tab, insert an `Area2D` node and rename it to `NPC`.
2. At this point, let's also include a `CollisionShape2D` rectangle to the NPC. It's useful for later stages and removes the glaring yellow warning symbol that might appear in the workspace.
3. With the `NPC` node selected, add a `Sprite2D` node. This will let us create a visible sprite for our character.
4. Now we want to set the image for our NPC sprite. Copy the troll portrait into the Godot project directory. In the properties panel, locate and choose the required image as an `ImageTexture`.
5. Set the transform of the image size to scale 0.15. Drag the NPC image to somewhere near the scene. At this point the project should build and run and you should see the river troll NPC token.

The ChatEntity class
--------------------

The `ChatEntity` class is a base class designated for nodes that will interact with the Semantic Kernel. The class handles instances when the chat entity is in conversation with another.

.. code-block:: csharp

   using Godot;
   using System;

   public partial class ChatEntity : Area2D
   {
       // Called when the node enters the scene tree for the first time.
       public override void _Ready()
       {
       }
   }
   
.. code-block:: csharp

   public class ChatEntity : Area2D
   {
       [Export]
       public string ChatName;

       [Export(PropertyHint.MultilineText)]
       public string ChatDescr;

       // Called when the node enters the scene tree for the first time.
       public override void _Ready()
       {
       }
   }

Next, add the methods for handling messages: `SendMsg` and `ReceiveMsg`.

.. code-block:: csharp

   [Signal]
   public delegate void MsgSentEventHandler(string msg);

   public void SendMsg(string message)
   {
       //TODO: Logic for sending a message
   }

   public string ReceiveMsg(string message)
   {
       //TODO: Logic for receiving a message and returning a response
       
       return "response";  
   }

Now the completed `ChatEntity` class should look like this:

.. code-block:: csharp

   public partial class ChatEntity : Area2D
   {
       [Export]
       public string ChatName;

       [Export(PropertyHint.MultilineText)]
       public string ChatDescr;

       internal ChatEntity _inConvoWith;

       [Signal]
       public delegate void MsgSentEventHandler(string msg);

       public virtual void SendMsg(string msg)
       {
           GD.Print(ChatName + ": " + msg);
           CallDeferred("emit_signal", "MsgSent", msg);
       }

       public virtual void ReceiveMsg(string msg)
       {
           // This function will be overridden later by a child class
       }
   }

The ChatAI class
----------------

In this class, key methods include `GetApiKey`, a method to initialize GPT model via Semantic Kernel, and a method to receive message and respond asynchronously.

First, define the `ChatAI` class.

.. code-block:: csharp

   [GlobalClass]
   public partial class ChatAI : ChatEntity
   {
   }

Define the methods for handling message reception and response.

.. code-block:: csharp

   protected virtual void HandleReply(System.Threading.Tasks.Task<string> replyTask)
   // If there are no errors for the reply, send the message
   if (replyTask.Exception == null)
   {
       SendMsg(replyTask.Result);
   }
   // If there were some errors for the reply, send a message about the errors
   else
   {
       string errMsg = "Could not get reply from " + ChatName;
       GD.PrintErr(errMsg + ": ", replyTask.Exception.Message);
       SendMsg(errMsg);
   }

   // Notifies semantic kernel agent about some event or other important piece of information
   public void Notify(string message)
   {
       GD.Print($"NOTIFY: {message}");
       _chat.AddUserMessage(message);
   }

   ...

   private string GetApiKey()
   {
       ...
       return apiKey;
   }

Arguing NPCs
------------

Create a text message for the NPCs to argue. 

.. code-block:: bash

   # Insert Message.txt here

Then add the following lines to `MainGame`.

.. code-block:: csharp

   using Godot;
   using Microsoft.SemanticKernel;

   public partial class MainGame : Node
   {
       public override void _Ready()
       {
           GD.Print("Semantic Kernel is ready!");

           // Get the troll ChatEntities
           ChatEntity eastTroll = GetNode<ChatEntity>("East Troll");
           ChatEntity westTroll = GetNode<ChatEntity>("West Troll");

           eastTroll._inConvoWith = westTroll;
           westTroll._inConvoWith = eastTroll;

           // Connect up the MsgSent signals
           eastTroll.MsgSent += westTroll.ReceiveMsg;
           westTroll.MsgSent += eastTroll.ReceiveMsg;

           // Start the conversation
           eastTroll.SendMsg($"I am the {eastTroll.ChatName}! And my side is the best side of the river!");
       }
   }
