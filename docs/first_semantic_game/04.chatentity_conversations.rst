ChatEntity Conversations
========================

Nearby ChatEntities
--------------------

Next, we'll write some properties and methods to keep track of other nearby entities. This will be
used by the ``ChatPlayer`` node to display a list of nearby entities to the player.


List of Nearby Entities
^^^^^^^^^^^^^^^^^^^^^^^

Let's first set up the list that will hold all of the nearby entities. We'll use a C# list for
this, so be sure to add the appropriate ``using`` statement.

.. code-block:: csharp

    using Godot;
    using System.Collections.Generic;  // allows us to use the List class

    [GlobalClass]
    public partial class ChatEntity : Area2D
    {
        (...)

        // List of ChatEntities currently in range
        protected List<ChatEntity> _nearbyChatEntities = new List<ChatEntity>();

        (...)
    }

The Area2D Signals
^^^^^^^^^^^^^^^^^^

Now, we want to write a few methods to define what should happen when another entity enters the
vicinity of this entity. Since ``ChatEntity`` extends Godot's built-in ``Area2D`` node, we can
build this behavior off of its
`signals <https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_signals.html>`_
``AreaEntered`` and ``AreaExited``. These signals are emitted whenever another ``Area2D`` node
enters/exits the collision shape of the first ``Area2D``. Let's first just hook these signals up to
methods ``OnAreaEntered()`` and ``OnAreaExited()``, which we will declare later.

.. code-block:: csharp

    // Called when the node enters the scene tree for the first time.
    public override void _Ready()
    {
        // Connect the signals for when another ChatEntity enters or exits the area
        AreaEntered += OnAreaEntered;
        AreaExited += OnAreaExited;
    }

These signals will be emitted whenever *any* other ``Area2D`` node enters/exits the area of this
entity. Since we only want to respond if the other node is also a ``ChatEntity``, let's have our
``OnAreaEntered()`` and ``OnAreaExited()`` check the type of the exiting/entering node and call
additional methods ``OnChatEntityEntered()`` and ``OnChatEntityExited()`` if the node is a
``ChatEntity``.

.. code-block:: csharp

    // Called when another Area2D enters the collision area of this ChatEntity
    private void OnAreaEntered(Area2D enteringArea2D)
    {
        if (enteringArea2D is ChatEntity enteringChatEntity)
            OnChatEntityEntered(enteringChatEntity);
    }

    // Called when another Area2D exits the collision area of this ChatEntity
    private void OnAreaExited(Area2D exitingArea2D)
    {
        if (exitingArea2D is ChatEntity exitingChatEntity)
            OnChatEntityExited(exitingChatEntity);
    }

Other Methods
^^^^^^^^^^^^^

Now we can write the ``OnChatEntityEntered()`` and ``OnChatEntityExited()`` methods. For right now
these methods will simply add/remove entities from the ``_nearbyChatEntities`` list. However, we
might want to expand upon them in the ``ChatAI`` or ``ChatPlayer`` scripts, so we'll make them
``virtual`` here.

.. code-block:: csharp

    // Called when another ChatEntity enters the collision area of this ChatEntity
    protected virtual void OnChatEntityEntered(ChatEntity enteringChatEntity)
    {
        _nearbyChatEntities.Add(enteringChatEntity);
    }

    // Called when another ChatEntity enters the collision area of this ChatEntity
    protected virtual void OnChatEntityExited(ChatEntity exitingChatEntity)
    {
        _nearbyChatEntities.Remove(exitingChatEntity);
    }

Finally, it would be convenient to be able to quickly find out which of the nearby entities is
"physically" the closest. To achieve this, we'll write a method that searches through all of the
entities in the ``_nearbyChatEntities`` list and returns the one whose ``GlobalPosition`` property
is closest to this entity.

.. code-block:: csharp

    // Returns the nearest ChatEntity in _nearbyChatEntities
    public ChatEntity NearestChatEntity()
    {
        // No nearby entities, return null
        if (_nearbyChatEntities.Count == 0)
        {
            return null;
        }
        // Otherwise, search through and find the nearest ChatEntity
        else
        {
            ChatEntity nearestChatEntity = _nearbyChatEntities[0];

            foreach (ChatEntity currentChatEntity in _nearbyChatEntities)
            {
                float nearestDistance = GlobalPosition.DistanceTo(nearestChatEntity.GlobalPosition);
                float currentDistance = GlobalPosition.DistanceTo(currentChatEntity.GlobalPosition);

                if (currentDistance < nearestDistance)
                    nearestChatEntity = currentChatEntity;
            }

            return nearestChatEntity;
        }
    }

Part 3: Messaging
-----------------

The last aspect of the ``ChatEntity`` script that we need to write will handle messaging. For this
project, all messaging will happen in conversations between two entities. In other words, to send
or receive any messages, an entity will first have to start a conversation with another entity.
Then, while in that conversation, they will only be able to send messages to and receive messages
from each other.

_inConvoWith Property
^^^^^^^^^^^^^^^^^^^^^

We'll first set up a property that will hold a reference to the other entity that this
entity is currently in conversation with. If this enitty is not in a conversation, then this
property will be null.

.. code-block:: csharp

    // Holds a reference to the other ChatEntity that this ChatEntity is currently in conversation with
    protected ChatEntity _inConvoWith = null;

We can also write a simple method that checks whether this property is not null (i.e. the entity is
in a conversation).

.. code-block:: csharp

    // Returns true if currently in a conversation, false otherwise
    public virtual bool InConvo()
    {
        return _inConvoWith != null;
    }

Sending and Receiving Messages
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In order to facilitate sending messages between two entities, we'll set up a Godot
`signal <https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_signals.html>`_
to be emitted by an entity when it sends a message. This signal will carry the content of the
message as a parameter and will be picked up by the other entity.

.. code-block:: csharp

    // A Godot signal for sending a message
    [Signal]
    public delegate void MsgSentEventHandler(string msg);

Now, let's set up some basic stub methods for handling receiving and sending messages. For now, the
``SendMsg()`` method will simply emit the ``MsgSent`` signal (using ``CallDeferred()`` for thread
safety), but we'll declare it ``virtual`` so it can be expanded. The ``ReceiveMsg()`` method is
just a stub that will need to be overridded by the ``ChatAI`` and ``ChatPlayer`` scripts.

.. code-block:: csharp

    // A useful shorthand for sending a message
    public virtual void SendMsg(string msg)
    {
        CallDeferred("emit_signal", SignalName.MsgSent, msg);
    }

    // Called when ChatEntity _inConvoWith emits a MsgSent signal
    public virtual void ReceiveMsg(string msg)
    {
        // Definition should be filled in by inheriting class
    }

Starting and Ending Conversations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Finally, we can write the methods for starting and ending a conversation. These methods will first do
some basic checks to make sure the desired operation is valid. Then they will set the
``_inConvoWith`` property according to the desired operation. Last, they will connect or disconnect
the ``MsgSent`` signals of each entity with the ``ReceiveMsg()`` method of the other entity.

.. code-block:: csharp

    // Attempts to start a conversation with another ChatEntity.
    // Will fail and return false if either ChatEntity is already in a conversation.
    public virtual bool StartConvo(ChatEntity otherChatEntity)
    {
        // Check to make sure neither ChatEntity is already in a conversation
        if (_inConvoWith != null || otherChatEntity._inConvoWith != null)
            return false;

        // Put both ChatEntities in conversation mode
        _inConvoWith = otherChatEntity;
        otherChatEntity._inConvoWith = this;

        // Connect up the MsgSent signals
        MsgSent += otherChatEntity.ReceiveMsg;
        otherChatEntity.MsgSent += ReceiveMsg;

        // Return success
        return true;
    }

    // Attempts to end a conversation with another ChatEntity
    // Will fail and return false if otherChatEntity is not in a conversation with this ChatEntity
    public virtual bool EndConvo(ChatEntity otherChatEntity)
    {
        // Check to make sure both ChatEntities are in conversation with each other
        if (_inConvoWith != otherChatEntity || otherChatEntity._inConvoWith != this)
            return false;

        // Take both ChatEntities out of conversation mode
        _inConvoWith = null;
        otherChatEntity._inConvoWith = null;

        // Disconnect the MsgSent signals
        MsgSent -= otherChatEntity.ReceiveMsg;
        otherChatEntity.MsgSent -= ReceiveMsg;

        // Return success
        return true;
    }
