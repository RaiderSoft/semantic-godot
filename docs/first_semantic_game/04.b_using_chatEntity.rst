Using ChatEntity
================

In this section, we will extend the ``ChatEntity`` node type with the ``ChatAI`` node type (to be
used by NPCs) and the ``ChatPlayer`` node (to be used by player characters). By the end of this
section, we should be able to see when two characters get close enough to see each other, when they
start and end conversations, and when they send and respond to messages. (Note: Since we don't have
the UI set up yet, all of this will be shown in the terminal for now and messages will need to be
hard-coded into our scripts.)

Part 1: ChatAI
--------------

Now that we have the ``ChatEntity`` node, we can extend it to create the ``ChatAI`` node, which is
the node that we will actually attach to NPCs. This is the node that will do all of the direct
communication with Semantic-Kernel.

Writing the Script
^^^^^^^^^^^^^^^^^^

* Need to create a new script that defines a ``[GlobalClass]`` node that inherits from ``ChatEntity``.
* Can pull in stuff created in "Setting Up Semantic-Kernel".
* Connect up with Semantic-Kernel in ``_Ready()``, using ``GetApiKey()``.
* The method SendMsg is same as in ChatAgent (just needs to emit the signal). The method ReceiveMsg is overridden. It passes the message on to SK/ChatGPT and starts a task to get a reply from SK/ChatGPT.
* When the reply task is complete, it calls the method HandleReply. This just ensures that there were no errors and then calls SendMsg with the SK/ChatGPT reply.
* There is a new method Notify which is essentially just a wrapper for sending a message to SK/ChatGPT (and not trying to get a reply).
* There is no code for a ChatAI to start or end a conversation. However, this could be easily added in by using/overriding the parent methods StartConvo and EndConvo.

Adding to Gralk Scene
^^^^^^^^^^^^^^^^^^^^^

* Add ``ChatAI`` to the Gralk scene.
* Set ``ChatName`` and ``ChatDescr`` properties. (Need some explanation for the format of the ``ChatDescr`` property.)
* Add a ``CollisionShape2D`` as a child of the ``ChatAI`` node. Give the ``CollisionShape2D`` a suitable shape (such as a circle with a radius of 64 px).

Part 2: ChatPlayer
------------------

Finally, we can also extend ``ChatEntity`` to create the ``ChatPlayer`` node. This node will be
attached to the player character and will allow it to interact with the ChatAI nodes. It will be
controlled by keyboard and UI input from the player.

Writing the Script
^^^^^^^^^^^^^^^^^^

* Need to create a new script that defines a ``[GlobalClass]`` node that inherits from ``ChatEntity``.
* The ``_Input()`` method is called whenever there is input. It only does something if that input is to start or end a conversation, in which case it calls ``StartConvo()`` and ``EndConvo()``, respectively. Also prints notifications out to the console.
* The methods ``StartConvo()`` and ``EndConvo()`` are overridden. Besides calling the base methods from ``ChatEntity``, they also notify the other entity that a conversation has started (assuming the other entity is a ``ChatAI``).
* The methods ``OnChatEntityEntered()`` and ``OnChatEntityExited()`` are overridden so that they also print out when an entity enters or leaves.
* The methods ``SendMsg()`` and ``ReceiveMsg()`` are overridden so that any incoming or outgoing messages are printed to the console with the name of the entity that sent them.

**Note:** The following will be added later when creating the UI:

* ``_controlHint`` property and ``_Process()`` method used to keep it updated
* The signals used to notify the UI of updates/changes
* Emitting these signals from the various methods (instead of printing to the console)

Adding to Seraphis Scene
^^^^^^^^^^^^^^^^^^^^^^^^

* Add ``ChatAI`` to the Gralk scene.
* Set ``ChatName`` and (optionally) ``ChatDescr`` properties.
* Add a ``CollisionShape2D`` as a child of the ``ChatAI`` node. Give the ``CollisionShape2D`` a suitable shape (such as a circle with a radius of 64 px).

Part 3: Try it Out
------------------

...