The Player
==========

In this section we will create the ``ChatPlayer`` node, which will be another extension of
``ChatEntity``. This node will be attached to the player character and will allow it to interact
with the ChatAI nodes. It will be controlled by keyboard and UI input from the player. By the end
of this section, we should be able to see when the player gets close enough to "see" Gralk, when
they start and end conversations, and when they send and respond to messages.

.. note::

    Since we don't have the UI set up yet, all of this will be shown in the output terminal for now
    and messages will need to be hard-coded into our scripts. After we create the UI in the next
    section, everything will be visible in the game screen.

Part 1: Writing the ChatPlayer Script
-------------------------------------

To start, we'll write the ``ChatPlayer`` script, which will be an extension of ``ChatEntity`` that
defines how players will interact with AI-powered NPCs. Right-click the filesystem dock and select
"New Script...". Make sure the language is set to C# and it inherits from ``ChatEntity``. Save it
as *ChatPlayer.cs*.

Once the script is created, open it up and add the ``[GlobalClass]`` attribute above the class
declaration.

.. code-block:: csharp

    using Godot;

    [GlobalClass]
    public partial class ChatPlayer : ChatEntity
    {
        (...)
    }

Properties
^^^^^^^^^^

Now that the ``ChatPlayer`` class is set up, we can add a few properties to it. First, add a
``_controlHint`` property. This will hold a message that will be displayed to the player to
indicate what kinds of inputs and actions they can do at any given moment.

.. code-block:: csharp

    // The current control hint
    private string _controlHint;

Next, add a few signals. We'll set up these signals to be emitted whenever ``ChatPlayer`` does
anything that we might want the UI to be aware of.

.. code-block:: csharp

    // Signals for connecting to the UI
    [Signal]
    public delegate void ControlHintUpdatedEventHandler(string controlHint);
    [Signal]
    public delegate void ChatEntityAddedEventHandler(ChatEntity chatEntity);
    [Signal]
    public delegate void ChatEntityRemovedEventHandler(ChatEntity chatEntity);
    [Signal]
    public delegate void ConvoStartedEventHandler();
    [Signal]
    public delegate void ConvoEndedEventHandler();
    [Signal]
    public delegate void MsgAddedEventHandler(ChatEntity sender, string msg);

.. note::

    Our use of signals here follows the "call down, signal up" convention. Although the UI will not
    technically be the parent or ancestor of ``ChatPlayer``, it will exist somewhat higher up in
    the scene tree. Additionally, it wouldn't ever really make sense to use the UI where there is
    no ``ChatPlayer`` node, but it could make sense to use the ``ChatPlayer`` node in a situation
    where there is no UI. Using signals here makes it so that the UI doesn't have to exist in order
    for ``ChatPlayer`` to function properly.

Control Hint Methods
^^^^^^^^^^^^^^^^^^^^

The first method to add in the ``ChatPlayer`` script is the ``_Process()`` method, which we'll use
to keep the control hint updated. Each frame, we'll evaluate the current game situation and
determine whether we need to update the control hint. If we do update it, we'll also emit a signal
indicating that.

.. code-block:: csharp

    // Called every frame. 'delta' is the elapsed time since the previous frame.
    public override void _Process(double delta)
    {
        // Figure out what the control hint should be for this frame
        string newControlHint = "Use the arrow keys to move";
        if (InConvo())
        {
            newControlHint = "Press ESC to end the conversation";
        }
        else
        {
            ChatEntity nearestChatEntity = NearestChatEntity();
            if (nearestChatEntity != null)
                newControlHint = "Press SHIFT to talk with " + nearestChatEntity.ChatName;
        }
        // If the control hint should be different, update it
        if (newControlHint != _controlHint)
        {
            _controlHint = newControlHint;
            GD.Print("Control Hint: " + _controlHint);
            EmitSignal("ControlHintUpdated", _controlHint);
        }
    }

.. note::

    We've added a ``GD.Print()`` statement to this method so that we can see in the output terminal
    when the control hint changes. The other methods we'll write for ``ChatPlayer`` will have
    similar print statements. This is a temporary solution until we complete the UI in the next
    section.

Conversation Methods
^^^^^^^^^^^^^^^^^^^^

The next few methods we'll write will control starting and ending conversations.

* Add ``start_convo`` and ``end_convo`` actions to the input map.
* ``_Input()`` method used to listen to player input SHIFT and ESC. Starts or ends a conversation
  accordingly.

.. code-block:: csharp

    public override void _Input(InputEvent @event)
    {
        if (InConvo())
        {
            if (@event.IsActionPressed("end_convo"))
                EndConvo(_inConvoWith);
        }
        else
        {
            if (@event.IsActionPressed("start_convo"))
            {
                ChatEntity nearestChatEntity = NearestChatEntity();
                if (nearestChatEntity != null)
                    StartConvo(nearestChatEntity);
            }
        }
    }

* ``StartConvo()`` and ``EndConvo()`` start and end conversations.
* They override the ``ChatEntity`` methods.

.. code-block:: csharp

    // Attempts to start a conversation with another ChatEntity.
    // Will fail and return false if otherChatEntity is already in a conversation.
    public override bool StartConvo(ChatEntity otherChatEntity)
    {
        // Do the basic stuff
        if (!base.StartConvo(otherChatEntity))
            return false;

        // If otherChatEntity is a ChatAI, notify it of the start of the conversation
        if (otherChatEntity is ChatAI otherChatAI)
            otherChatAI.Notify(ChatName + " has started a conversation with you.");

        // Indicate that a conversation was started
        GD.Print("Started a conversation with " + otherChatEntity.ChatName);
        EmitSignal(SignalName.ConvoStarted);

        // Return success
        return true;
    }

    // Attempts to end a conversation with another ChatEntity
    // Will fail and return false if otherChatEntity is not in a conversation with this ChatEntity
    public override bool EndConvo(ChatEntity otherChatEntity)
    {
        // Do the basic stuff
        if (!base.EndConvo(otherChatEntity))
            return false;

        // If otherChatEntity is a ChatAI, notify it of the end of the conversation
        if (otherChatEntity is ChatAI otherChatAI)
            otherChatAI.Notify(ChatName + " has ended their conversation with you.");

        // Indicate that a conversation was ended
        GD.Print("Ended a conversation with " + otherChatEntity.ChatName);
        EmitSignal(SignalName.ConvoEnded);

        // Return success
        return true;
    }

Messaging Methods
^^^^^^^^^^^^^^^^^

* Override ``SendMsg()`` and ``ReceiveMsg()`` so that they also emit signals to be picked up by the
  UI.

.. code-block:: csharp

    // A useful shorthand for sending a message
    // Called when the MsgSent signal is emitted by UI
    public override void SendMsg(string msg)
    {
        // Send the message to ChatEntity _inConvoWith
        base.SendMsg(msg);

        // Emit a signal that there is a new message (for UI)
        EmitSignal(SignalName.MsgAdded, this, msg);
    }

    // Called when ChatEntity _inConvoWith emits a MsgSent signal
    public override void ReceiveMsg(string msg)
    {
        // Emit a signal that there is a new message (for UI)
        EmitSignal(SignalName.MsgAdded, _inConvoWith, msg);
    }

Nearby ChatEntity Methods
^^^^^^^^^^^^^^^^^^^^^^^^^

* ``OnChatEntityEntered()`` and ``OnChatEntityExited()`` track chat entities as they come into or
  move out of the player's vicinity.

.. code-block:: csharp

    protected override void OnChatEntityEntered(ChatEntity enteringChatEntity)
    {
        base.OnChatEntityEntered(enteringChatEntity);
        GD.Print(enteringChatEntity + " has entered your vicinity");
        EmitSignal("ChatEntityAdded", enteringChatEntity);
    }

    protected override void OnChatEntityExited(ChatEntity exitingChatEntity)
    {
        base.OnChatEntityExited(exitingChatEntity);
        GD.Print(exitingChatEntity + " has exited your vicinity");
        EmitSignal("ChatEntityRemoved", exitingChatEntity);
    }

Part 2: Using the ChatPlayer Node
---------------------------------

TODO

Attaching to Seraphis
^^^^^^^^^^^^^^^^^^^^^

* Add ``ChatPlayer`` to the Seraphis scene (should be in "Create New Node" dialogue; rebuild if not).
* Set ``ChatName`` and (optionally) ``ChatDescr`` properties.
* Add a ``CollisionShape2D`` as a child of the ``ChatAI`` node. Give the ``CollisionShape2D`` a suitable shape (such as a circle with a radius of 75 px).
* Also edit the *Seraphis.cs* script so that the player cannot move while in a conversation.

Try It Out
^^^^^^^^^^

* Will need to hardcode some messages into the script, perhaps when a conversation is started.
* Can see stuff happening in the terminal ("Output" on Godot).
